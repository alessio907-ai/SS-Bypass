# =====================================================
# CrystalPVPJarTester BLUE - ULTIMATE
# CrystalPVP 
# =====================================================

$ErrorActionPreference = "SilentlyContinue"

# ---------------- UI HELPERS ----------------
function H1($t){
    Write-Host ""
    Write-Host "═══════════════════════════════════════" -ForegroundColor DarkBlue
    Write-Host " $t" -ForegroundColor Cyan
    Write-Host "═══════════════════════════════════════" -ForegroundColor DarkBlue
    Write-Host ""
}
function Sec($t){ Write-Host "`n--- $t ---" -ForegroundColor Cyan }
function Info($t){ Write-Host "  $t" -ForegroundColor Blue }
function Bad($t){ Write-Host "  $t" -ForegroundColor Red }

# ---------------- ENTRY ----------------
function Start-CheatScan {
    Clear-Host
    H1 "CrystalPVP Cheat Analyser"
    Info "Made by Main2Packet"
    Write-Host ""

    # --------- JAVA PROCESS ----------
    $javaProc = Get-Process java,javaw -ErrorAction SilentlyContinue |
        Sort-Object StartTime | Select-Object -First 1

    if (-not $javaProc) {
        Bad "✖ Minecraft (Java) not running"
        Read-Host "Press Enter"
        return
    }

    $cmd = (Get-CimInstance Win32_Process -Filter "ProcessId=$($javaProc.Id)").CommandLine

    # --------- UPTIME ----------
    $uptime = (Get-Date) - $javaProc.StartTime
    Sec "Minecraft Uptime"
    Info "$($javaProc.Name) PID $($javaProc.Id) | $($uptime.Hours)h $($uptime.Minutes)m $($uptime.Seconds)s"

    # --------- JVM ARG SCAN ----------
    $jvmFindings = Scan-JVMArguments $cmd
    Sec "JVM / JavaAgent Scan"
    if ($jvmFindings.Count -gt 0) {
        $jvmFindings | ForEach-Object { Bad "❌ $_" }
        $jvmSuspicious = $true  # NEU: Flag für JVM Findings
    } else {
        Info "✔ No suspicious JVM arguments"
        $jvmSuspicious = $false  # NEU: Flag für JVM Findings
    }

    # --------- GAME DIR ----------
    $mcPath = Get-RunningMinecraftPath
    if (-not $mcPath) {
        Bad "✖ Could not determine gameDir"
        Read-Host "Press Enter"
        return
    }

    Sec "Detected Minecraft Instance"
    Info "$mcPath"

    # --------- MOD SCAN ----------
    $modsPath = Join-Path $mcPath "mods"
    $mods = Get-ChildItem $modsPath -Force -File -Filter "*.jar" -ErrorAction SilentlyContinue

    $flagged=@()
    $clean=@()
    $unknown=@()
    $i=0

    # Cheat Strings (Habibi)
    $cheatStrings = @(
        "AimAssist","AnchorTweaks","AutoAnchor","AutoCrystal","AutoDoubleHand",
        "AutoHitCrystal","AutoPot","AutoTotem","AutoArmor","InventoryTotem",
        "Hitboxes","JumpReset","LegitTotem","PingSpoof","SelfDestruct",
        "ShieldBreaker","TriggerBot","Velocity","AxeSpam","WebMacro","FastPlace"
    )

    Sec "Scanning Mods..."
    foreach ($m in $mods) {
        $i++
        Write-Host "`r[~] Scanning $i / $($mods.Count)" -NoNewline -ForegroundColor Cyan

        # ---------- ANALYZE LOCAL ----------
        $r = Analyze-Mod $m.FullName $m.Name

        # ---------- SHA1 / Modrinth / Megabase ----------
        $hash = Get-SHA1 -filePath $m.FullName
        $modDataModrinth = Fetch-Modrinth -hash $hash
        $modDataMegabase = Fetch-Megabase -hash $hash

        if ($modDataModrinth.Slug -or $modDataMegabase.name) {
            $r.Verified = $true
        }

        # ---------- STRING SCAN ----------
        $stringsFound = Check-Strings $m.FullName $cheatStrings
        if ($stringsFound.Count -gt 0) {
            $r.IsSuspicious = $true
            $r.Hits += $stringsFound
            $r.Reason += "; Cheat strings detected"
        }

        # ---------- Hidden Check ----------
        if ($m.Attributes -band [System.IO.FileAttributes]::Hidden) {
            $r.Hidden = $true
            if ($r.IsSuspicious) {
                $r.Reason += "; Diese Mod wurde versteckt, um ein SS zu umgehen"
            }
        }

        if ($r.IsSuspicious) { $flagged += $r }
        elseif ($r.Verified) { $clean += $r }
        else { $unknown += $r }
    }
    Write-Host "`r$(' ' * 80)`r"

    # --------- CLEAN MODS ----------
    if ($clean.Count -gt 0) {
        Sec "Verified / Clean Mods"
        $clean | ForEach-Object {
            Info "✔ $($_.ModName)"
        }
    }

    # --------- UNKNOWN MODS ----------
    if ($unknown.Count -gt 0) {
        Sec "Unknown Mods"
        $unknown | ForEach-Object {
            if ($_.Hidden) { Info "⚠ $($_.ModName) (hidden mod)" } 
            else { Info "➖ $($_.ModName)" }
        }
    }

    # --------- CHEAT MODS ----------
    if ($flagged.Count -gt 0) {
        Sec "Cheat Mods"
        $flagged | ForEach-Object {
            Bad "❌ $($_.ModName)"
            Bad "   Reason: $($_.Reason)"
            if ($_.Hits.Count -gt 0) { Bad "   Hits: $($_.Hits -join ', ')" }
            if ($_.Hidden) { Bad "    Diese Mod wurde versteckt, um ein SS zu umgehen" }
        }
    }

    # --------- TASK MANAGER SCAN ----------
    Sec "Task Manager Scan"
    $knownProcesses = Get-KnownCheatProcesses
    if ($knownProcesses.Count -gt 0) {
        $knownProcesses | ForEach-Object {
            Bad "❌ Cheat Process Running: $($_.Name) (PID: $($_.Id))"
        }
    } else {
        Info "✔ No known cheat processes found"
    }

    # --------- NEUE DESKTOP SCAN LOGIK ----------
    # Desktop Scan NUR bei JVM Findings
    if ($jvmSuspicious) {
        Sec "Desktop Scan (Triggered by JVM findings)"
        Bad "⚠ Desktop scan activated because JVM suspicious findings:"
        $jvmFindings | ForEach-Object { Bad "   - $_" }
        
        Write-Host "`n[1/2] Scanning Desktop for EXEs (0.5-2.5MB)..." -ForegroundColor Yellow
        $desktopExeResults = Scan-DesktopForEXEsBySize
        
        Write-Host "[2/2] Analyzing suspicious files..." -ForegroundColor Yellow
        
        if ($desktopExeResults.Count -gt 0) {
            Bad "`n⚠ Found $($desktopExeResults.Count) suspicious EXE files on Desktop!"
            $desktopExeResults | ForEach-Object {
                Bad "❌ SUSPICIOUS EXE: $($_.FileName)"
                Bad "   Path: $($_.FullPath)"
                Bad "   Size: $($_.SizeMB) MB (Cheat range: 0.5-2.5MB)"
                Bad "   Created: $($_.CreationTime)"
                Bad "   Hash: $($_.SHA256)"
                Bad ""
            }
        } else {
            Info "✔ No suspicious EXE files found on Desktop (size 0.5-2.5MB)"
        }
    } else {
        Sec "Desktop Scan"
        Info "Skipped - No JVM findings detected"
        Info "Desktop scan only runs when -javaagent or similar JVM args found"
    }

    # --------- DESKTOP SCAN (ORIGINAL) ----------
    Sec "Desktop Scan (Original)"
    $desktopPath = [System.Environment]::GetFolderPath('Desktop')
    $suspiciousDesktopFiles = Scan-DesktopForInjectors -Path $desktopPath
    if ($suspiciousDesktopFiles.Count -gt 0) {
        $suspiciousDesktopFiles | ForEach-Object {
            Bad "❌ Suspicious file on Desktop: $($_.Name)"
            Bad "   Path: $($_.FullPath)"
            Bad "   Reason: $($_.Reason)"
            Bad "   Hash: $($_.SHA1)"
            Bad ""
        }
    } else {
        Info "✔ No suspicious files found in Desktop"
    }

    # --------- APPDATA SCAN ----------
    Sec "Scanning AppData (Common Cheat Locations)"
    $appDataCheats = Scan-AppDataForCheats
    if ($appDataCheats.Count -gt 0) {
        $appDataCheats | ForEach-Object {
            Bad "❌ Cheat found in AppData: $($_.Name)"
            Bad "   Path: $($_.FullPath)"
            Bad "   Type: $($_.Type)"
            Bad ""
        }
    } else {
        Info "✔ No cheats found in AppData folders"
    }

    # --------- SUMMARY ----------
    Sec "Summary"
    Info "Verified / Clean Mods: $($clean.Count)"
    Info "Unknown Mods: $($unknown.Count)"
    Info "Cheat Mods: $($flagged.Count)"
    Info "JVM Findings: $($jvmFindings.Count)"
    if ($jvmSuspicious) {
        Info "Desktop EXEs (0.5-2.5MB): $($desktopExeResults.Count)"
    }

    Write-Host "`nScan finished at $(Get-Date)" -ForegroundColor Blue
    Read-Host "Press Enter"
}

# ---------------- NEUE FUNKTION FÜR DESKTOP SCAN NACH GRÖßE ----------------
function Scan-DesktopForEXEsBySize {
    $suspiciousFiles = @()
    $desktopPath = [Environment]::GetFolderPath('Desktop')
    
    if (-not (Test-Path $desktopPath)) { return @() }
    
    # Alle EXE Dateien auf Desktop finden
    $exeFiles = Get-ChildItem -Path $desktopPath -Filter "*.exe" -File -ErrorAction SilentlyContinue
    
    foreach ($exe in $exeFiles) {
        try {
            # Größe prüfen: 0.5 MB - 2.5 MB
            $sizeMB = [math]::Round($exe.Length/1MB, 2)
            if ($sizeMB -ge 0.5 -and $sizeMB -le 2.5) {
                # Jede EXE in diesem Bereich als verdächtig markieren
                $suspiciousFiles += [PSCustomObject]@{
                    FileName = $exe.Name
                    FullPath = $exe.FullName
                    SizeMB = $sizeMB
                    CreationTime = $exe.CreationTime
                    SHA256 = (Get-FileHash -Path $exe.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue).Hash
                }
            }
        } catch {
            # Fehler ignorieren
        }
    }
    
    return $suspiciousFiles
}

# ---------------- NEUE FUNKTIONEN ----------------
function Get-KnownCheatProcesses {
    $cheatProcessNames = @(
        "prestigeclient", "vaponclient", "noraxclient", "wurst", "aristois",
        "meteor", "injector", "inject", "cheat", "hack", "client", "loader",
        "vape", "vapelite", "future", "rusher", "liquidbounce"
    )
    
    $allProcesses = Get-Process | Where-Object { $_.ProcessName -notmatch "^(conhost|svchost|explorer|System)$" }
    $foundProcesses = @()
    
    foreach ($process in $allProcesses) {
        $procNameLower = $process.ProcessName.ToLower()
        foreach ($cheatName in $cheatProcessNames) {
            if ($procNameLower -match $cheatName) {
                $foundProcesses += $process
                break
            }
        }
    }
    
    return $foundProcesses
}

function Scan-DesktopForInjectors {
    param($Path)
    
    $suspiciousFiles = @()
    
    # Bekannte Client/Injector Dateinamen
    $knownClientNames = @(
        "prestigeclient.exe", "vaponclient.exe", "noraxclient.exe", "wurst.exe", "aristois.exe",
        "meteor.exe", "injector.exe", "cheat.exe", "hack.exe", "client.exe", "loader.exe",
        "vape.exe", "vapelite.exe", "future.exe", "rusher.exe", "liquidbounce.exe",
        "minecraft-client.exe", "mc-client.exe", "pvp-client.exe", "crystalclient.exe"
    )
    
    $knownJarNames = @(
        "prestigeclient.jar", "vaponclient.jar", "noraxclient.jar", "wurst.jar", "aristois.jar",
        "meteor.jar", "cheat.jar", "hack.jar", "client.jar", "vape.jar", "vapelite.jar"
    )
    
    try {
        # EXE-Dateien prüfen
        $exeFiles = Get-ChildItem -Path $Path -Filter "*.exe" -File -ErrorAction SilentlyContinue
        
        foreach ($exe in $exeFiles) {
            $found = $false
            $reason = ""
            
            # 1. Direkter Name-Vergleich
            foreach ($knownName in $knownClientNames) {
                if ($exe.Name -eq $knownName) {
                    $found = $true
                    $reason = "Known cheat client name: $($exe.Name)"
                    break
                }
            }
            
            # 2. Größe prüfen (sehr kleine EXEs)
            if (-not $found -and $exe.Length -lt 20480) { # < 20KB
                $found = $true
                $reason = "Suspiciously small EXE file ($([math]::Round($exe.Length/1KB, 1)) KB)"
            }
            
            # 3. Versteckte Datei
            if (-not $found -and ($exe.Attributes -band [System.IO.FileAttributes]::Hidden)) {
                $found = $true
                $reason = "Hidden EXE file"
            }
            
            if ($found) {
                $suspiciousFiles += [PSCustomObject]@{
                    Name = $exe.Name
                    FullPath = $exe.FullName
                    Reason = $reason
                    SHA1 = (Get-FileHash -Path $exe.FullName -Algorithm SHA1 -ErrorAction SilentlyContinue).Hash
                }
            }
        }
        
        # JAR-Dateien prüfen
        $jarFiles = Get-ChildItem -Path $Path -Filter "*.jar" -File -ErrorAction SilentlyContinue
        
        foreach ($jar in $jarFiles) {
            foreach ($knownJar in $knownJarNames) {
                if ($jar.Name -eq $knownJar) {
                    $suspiciousFiles += [PSCustomObject]@{
                        Name = $jar.Name
                        FullPath = $jar.FullName
                        Reason = "Known cheat JAR file: $($jar.Name)"
                        SHA1 = (Get-FileHash -Path $jar.FullName -Algorithm SHA1 -ErrorAction SilentlyContinue).Hash
                    }
                    break
                }
            }
        }
        
    } catch {
        # Fehler ignorieren
    }
    
    return $suspiciousFiles
}

function Scan-AppDataForCheats {
    $cheatPaths = @()
    $commonCheatFolders = @(
        "$env:APPDATA\.minecraft\prestigeclient",
        "$env:APPDATA\.minecraft\vaponclient",
        "$env:APPDATA\.minecraft\noraxclient",
        "$env:APPDATA\.minecraft\cheats",
        "$env:APPDATA\.minecraft\hacks",
        "$env:APPDATA\.minecraft\mods\cheat",
        "$env:LOCALAPPDATA\Temp\prestige",
        "$env:LOCALAPPDATA\Temp\vapon",
        "$env:LOCALAPPDATA\Temp\norax",
        "$env:USERPROFILE\Downloads\prestige",
        "$env:USERPROFILE\Downloads\vapon",
        "$env:USERPROFILE\Downloads\norax"
    )
    
    foreach ($folder in $commonCheatFolders) {
        if (Test-Path $folder) {
            $folderItem = Get-Item $folder -ErrorAction SilentlyContinue
            $cheatPaths += [PSCustomObject]@{
                Name = $folderItem.Name
                FullPath = $folderItem.FullName
                Type = "Cheat Folder"
            }
            
            # Nach EXE/JAR in diesen Ordnern suchen
            $exeFiles = Get-ChildItem -Path $folder -Filter "*.exe" -File -ErrorAction SilentlyContinue
            $jarFiles = Get-ChildItem -Path $folder -Filter "*.jar" -File -ErrorAction SilentlyContinue
            
            foreach ($exe in $exeFiles) {
                $cheatPaths += [PSCustomObject]@{
                    Name = $exe.Name
                    FullPath = $exe.FullName
                    Type = "EXE in Cheat Folder"
                }
            }
            
            foreach ($jar in $jarFiles) {
                $cheatPaths += [PSCustomObject]@{
                    Name = $jar.Name
                    FullPath = $jar.FullName
                    Type = "JAR in Cheat Folder"
                }
            }
        }
    }
    
    return $cheatPaths
}

# ---------------- HELPER FUNCTIONS ----------------
function Scan-JVMArguments($cmd){
    $bad = @(
        "-javaagent:",
        "-noverify",
        "-Xbootclasspath",
        "DisableAttachMechanism",
        "fabric.development=true",
        "-Djdk.attach.allowAttachSelf"
    )
    $hits=@()
    foreach ($b in $bad) {
        if ($cmd -match [regex]::Escape($b)) { $hits += $b }
    }
    return $hits
}

function Scan-NativeDLLs($pid){
    $out=@()
    $mods = Get-Process -Id $pid -Module -ErrorAction SilentlyContinue
    foreach ($m in $mods) {
        if ($m.FileName -and $m.FileName -match "\.dll$") {
            if ($m.FileName -notmatch "System32|Java|jdk|jre") {
                $out += $m.FileName
            }
        }
    }
    return ($out | Select-Object -Unique)
}

function Get-RunningMinecraftPath {
    $java = Get-Process java,javaw -ErrorAction SilentlyContinue | Sort-Object StartTime -Descending
    foreach ($p in $java) {
        try {
            $cmd = (Get-CimInstance Win32_Process -Filter "ProcessId=$($p.Id)").CommandLine
            if ($cmd -match "-gameDir\s+""([^""]+)""") {
                if (Test-Path "$($matches[1])\mods") { return $matches[1] }
            }
            if ($cmd -match "([A-Za-z]:\\[^""]*?\.minecraft)") {
                if (Test-Path "$($matches[1])\mods") { return $matches[1] }
            }
        } catch {}
    }
    return $null
}

function Analyze-Mod($JarPath, $ModName) {
    $temp = Join-Path $env:TEMP ("cpvp_" + [guid]::NewGuid())
    New-Item $temp -ItemType Directory | Out-Null

    $hits=@()
    $sus=$false
    $reasons=@()
    $hidden=$false
    $verified=$false

    try {
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        [IO.Compression.ZipFile]::ExtractToDirectory($JarPath, $temp)

        $pkg = Scan-CheatPackages $temp
        $cls = Scan-SuspiciousClasses $temp

        if ($pkg.Hits.Count -gt 0) {
            $sus=$true
            $reasons+="Known cheat package"
            $hits+=$pkg.Hits
        }

        if ($cls.Hits.Count -ge 3) {
            $sus=$true
            $reasons+="Multiple suspicious class names"
            $hits+=$cls.Hits
        }
    } catch {
        $reasons+="Scan error"
    } finally {
        Remove-Item $temp -Recurse -Force -ErrorAction SilentlyContinue
    }

    [PSCustomObject]@{
        ModName=$ModName
        IsSuspicious=$sus
        Reason=$reasons -join "; "
        Hits=$hits | Select-Object -Unique
        Hidden=$hidden
        Verified=$verified
    }
}

# ---------------- ORIGINAL SCANS ----------------
function Scan-CheatPackages {
    param($ExtractPath)
    $hits=@()
    $cheatIds=@("meteorclient","net.wurst","wurstclient","aristois","futureclient","rusherhack","liquidbounce")
    $files=Get-ChildItem $ExtractPath -Recurse -File -ErrorAction SilentlyContinue
    foreach($f in $files){
        $rel=$f.FullName.Substring($ExtractPath.Length).ToLower()
        foreach($id in $cheatIds){ if($rel -match [regex]::Escape($id)){ $hits+="package:$id" } }
    }
    [PSCustomObject]@{ Hits=$hits | Select-Object -Unique }
}

function Scan-SuspiciousClasses {
    param($ExtractPath)
    $hits=@()
    $frags=@("killaura","crystalaura","autoclick","triggerbot","aimassist","autocrystal","clickcrystal",
             "anchormacro","wtap","tpaura","placecrystal","breakcrystal","autototem","autoinv","playeresp",
             "storageesp","fastexp","doubleanchor","autoexplode")
    $classes=Get-ChildItem $ExtractPath -Recurse -Filter "*.class" -ErrorAction SilentlyContinue
    foreach($c in $classes){
        try{
            $txt=[Text.Encoding]::UTF8.GetString([IO.File]::ReadAllBytes($c.FullName))
            foreach($f in $frags){ if($txt -match $f){ $hits+="class:$f" } }
        }catch{}
    }
    [PSCustomObject]@{ Hits=$hits | Select-Object -Unique }
}

# ---------------- HABIBI FEATURES ----------------
function Get-SHA1 { param([string]$filePath); return (Get-FileHash -Path $filePath -Algorithm SHA1).Hash }
function Get-ZoneIdentifier { param([string]$filePath); $ads = Get-Content -Raw -Stream Zone.Identifier $filePath -ErrorAction SilentlyContinue; if ($ads -match "HostUrl=(.+)") { return $matches[1] } else { return $null } }
function Fetch-Modrinth { param([string]$hash); try { $resp = Invoke-RestMethod -Uri "https://api.modrinth.com/v2/version_file/$hash" -Method Get -UseBasicParsing -ErrorAction Stop; if ($resp.project_id) { $proj = Invoke-RestMethod -Uri "https://api.modrinth.com/v2/project/$($resp.project_id)" -Method Get -UseBasicParsing -ErrorAction Stop; return @{ Name=$proj.title; Slug=$proj.slug } } } catch {}; return @{ Name=""; Slug="" } }
function Fetch-Megabase { param([string]$hash); try { $resp = Invoke-RestMethod -Uri "https://megabase.vercel.app/api/query?hash=$hash" -Method Get -UseBasicParsing -ErrorAction Stop; if (-not $resp.error) { return $resp.data } } catch {}; return $null }
function Check-Strings { param([string]$filePath, [string[]]$cheatStrings); $found=[System.Collections.Generic.HashSet[string]]::new(); $lines=Get-Content -Raw $filePath; foreach ($line in $lines){ foreach ($s in $cheatStrings){ if ($line -match $s) { $found.Add($s)|Out-Null } } }; return $found }

# ---------------- RUN ----------------
Start-CheatScan

