# =====================================================
# INJECTABLE CHEATS DETECTOR - ULTIMATE
# Findet injektierte Cheats in Java/Minecraft Prozessen
# =====================================================

$ErrorActionPreference = "SilentlyContinue"
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# ---------------- UI HELPERS ----------------
function Show-Banner {
    Clear-Host
    Write-Host ""
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Red
    Write-Host "‚ïë" -NoNewline -ForegroundColor Red
    Write-Host "      üéØ INJECTABLE CHEATS DETECTOR - ULTIMATE              " -NoNewline -ForegroundColor Yellow
    Write-Host "‚ïë" -ForegroundColor Red
    Write-Host "‚ïë" -NoNewline -ForegroundColor Red
    Write-Host "      Findet injektierte Cheats in Minecraft Prozessen      " -NoNewline -ForegroundColor Cyan
    Write-Host "‚ïë" -ForegroundColor Red
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Red
    Write-Host ""
}

function Show-Result($text, $type) {
    switch ($type) {
        "BAD" { Write-Host "  ‚ùå $text" -ForegroundColor Red }
        "WARN" { Write-Host "  ‚ö† $text" -ForegroundColor Yellow }
        "INFO" { Write-Host "  ‚Ñπ $text" -ForegroundColor Blue }
        "GOOD" { Write-Host "  ‚úì $text" -ForegroundColor Green }
        "DETECTED" { Write-Host "  üî• $text" -ForegroundColor Magenta }
    }
}

function Show-Section($title) {
    Write-Host ""
    Write-Host "‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨" -ForegroundColor DarkCyan
    Write-Host " $title" -ForegroundColor Cyan
    Write-Host "‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨‚ñ¨" -ForegroundColor DarkCyan
    Write-Host ""
}

# ---------------- MAIN ENTRY ----------------
function Start-InjectableCheatScan {
    Show-Banner
    
    Write-Host "  üë§ Benutzer: $env:USERNAME" -ForegroundColor Gray
    Write-Host "  üíª Computer: $env:COMPUTERNAME" -ForegroundColor Gray
    Write-Host "  üïê Zeit: $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Gray
    Write-Host ""
    
    # --------- MINECRAFT PROZESSE FINDEN ----------
    Show-Section "üéÆ MINECRAFT PROZESSE ERKENNEN"
    
    $minecraftProcesses = Get-Process | Where-Object {
        $_.ProcessName -match "^(java|javaw|minecraft|bedrock|tlauncher|lunar|feather)" -and
        $_.MainWindowTitle -match "Minecraft|Lunar|Badlion|TLauncher" -or
        $_.Path -match "minecraft"
    } | Sort-Object StartTime
    
    if ($minecraftProcesses.Count -eq 0) {
        Show-Result "Keine Minecraft/Java Prozesse gefunden" "WARN"
        Write-Host ""
        Read-Host "Dr√ºcke Enter zum Neustarten"
        Start-InjectableCheatScan
        return
    }
    
    Show-Result "Gefundene Prozesse: $($minecraftProcesses.Count)" "INFO"
    
    $totalCheatScore = 0
    $detectedInjections = @()
    
    foreach ($proc in $minecraftProcesses) {
        Write-Host ""
        Write-Host "  üîç Analysiere: " -NoNewline -ForegroundColor Cyan
        Write-Host "$($proc.ProcessName) (PID: $($proc.Id))" -ForegroundColor White
        
        # --------- 1. JVM ARGUMENTE ANALYSE ----------
        $jvmScore = Scan-JVM-For-Injections $proc.Id
        if ($jvmScore -gt 0) {
            $totalCheatScore += $jvmScore
            $detectedInjections += "JVM Injection (Score: $jvmScore)"
        }
        
        # --------- 2. MEMORY MODULE ANALYSE ----------
        $memoryScore = Scan-Memory-Modules $proc.Id
        if ($memoryScore -gt 0) {
            $totalCheatScore += $memoryScore
            $detectedInjections += "Memory Module (Score: $memoryScore)"
        }
        
        # --------- 3. DLL INJECTION DETECTION ----------
        $dllScore = Scan-DLL-Injections $proc.Id
        if ($dllScore -gt 0) {
            $totalCheatScore += $dllScore
            $detectedInjections += "DLL Injection (Score: $dllScore)"
        }
        
        # --------- 4. NETWORK CONNECTION CHECK ----------
        $networkScore = Scan-Network-Connections $proc.Id
        if ($networkScore -gt 0) {
            $totalCheatScore += $networkScore
            $detectedInjections += "Suspicious Network (Score: $networkScore)"
        }
        
        # --------- 5. PROCESS HOOK DETECTION ----------
        $hookScore = Scan-Process-Hooks $proc.Id
        if ($hookScore -gt 0) {
            $totalCheatScore += $hookScore
            $detectedInjections += "Process Hooks (Score: $hookScore)"
        }
    }
    
    # --------- ERGEBNISSE ----------
    Show-Section "üìä SCAN ERGEBNISSE"
    
    if ($totalCheatScore -eq 0) {
        Show-Result "KEINE injektierbaren Cheats erkannt!" "GOOD"
        Write-Host ""
        Show-Result "Dein Minecraft scheint sauber zu sein." "INFO"
    } else {
        Show-Result "üö® INJEKTIERBARE CHEATS ERKANNT!" "DETECTED"
        Write-Host ""
        Show-Result "Total Cheat Score: $totalCheatScore/100" "BAD"
        
        if ($totalCheatScore -gt 70) {
            Show-Result "‚ö† HOHE WAHRSCHEINLICHKEIT F√úR CHEATS!" "DETECTED"
        } elseif ($totalCheatScore -gt 40) {
            Show-Result "‚ö† VERD√ÑCHTIGE AKTIVIT√ÑTEN ERKANNT!" "WARN"
        }
        
        Write-Host ""
        Show-Result "Erkannte Injection-Typen:" "INFO"
        foreach ($injection in $detectedInjections) {
            Write-Host "    ‚Ä¢ $injection" -ForegroundColor Yellow
        }
    }
    
    # --------- DETAILLIERTE ANALYSE OPTIONEN ----------
    Show-Section "üîß DETAILLIERTE ANALYSE"
    
    Write-Host "  1. üîç DLL Injection Details anzeigen" -ForegroundColor Cyan
    Write-Host "  2. üß† Memory Scan durchf√ºhren" -ForegroundColor Cyan
    Write-Host "  3. üåê Netzwerkverbindungen pr√ºfen" -ForegroundColor Cyan
    Write-Host "  4. üïµÔ∏è‚Äç‚ôÇÔ∏è Versteckte Prozesse finden" -ForegroundColor Cyan
    Write-Host "  5. üìù Event Log analysieren" -ForegroundColor Cyan
    Write-Host "  6. üîÑ Erneut scannen" -ForegroundColor Cyan
    Write-Host "  7. üö™ Beenden" -ForegroundColor Cyan
    
    $choice = Read-Host "`nAuswahl (1-7)"
    
    switch ($choice) {
        "1" { Show-DLL-Details }
        "2" { Run-Memory-Scan }
        "3" { Show-Network-Details }
        "4" { Find-Hidden-Processes }
        "5" { Analyze-Event-Logs }
        "6" { Start-InjectableCheatScan }
        "7" { return }
        default { Start-InjectableCheatScan }
    }
}

# ---------------- DETECTION FUNCTIONS ----------------

function Scan-JVM-For-Injections($pid) {
    $score = 0
    
    try {
        $proc = Get-CimInstance Win32_Process -Filter "ProcessId=$pid"
        $cmdLine = $proc.CommandLine
        
        # Typische Injection-Argumente
        $injectionPatterns = @(
            "-javaagent:", "-agentlib:", "-agentpath:",
            "-Xbootclasspath:", "-noverify", "-Xverify:none",
            "-Djdk.attach.allowAttachSelf=true",
            "-XX:+DisableAttachMechanism",
            "-Djava.system.class.loader=",
            "-Dcom.sun.tools.attach.attachTimeout="
        )
        
        $cheatAgents = @(
            "injection", "injekt", "cheat", "client", "hack",
            "meteor", "wurst", "aristois", "future", "liquidbounce",
            "rusher", "kami", "phobos", "konas", "salhack"
        )
        
        foreach ($pattern in $injectionPatterns) {
            if ($cmdLine -match [regex]::Escape($pattern)) {
                $score += 15
                Write-Host "    ‚ùå JVM Arg: $pattern" -ForegroundColor Red
            }
        }
        
        foreach ($agent in $cheatAgents) {
            if ($cmdLine -match $agent) {
                $score += 20
                Write-Host "    ‚ùå Cheat Agent: $agent" -ForegroundColor Red
            }
        }
        
    } catch {
        # Fehler ignorieren
    }
    
    return $score
}

function Scan-Memory-Modules($pid) {
    $score = 0
    
    try {
        $modules = Get-Process -Id $pid -Module -ErrorAction SilentlyContinue
        
        $suspiciousModules = @()
        
        foreach ($module in $modules) {
            $moduleName = $module.ModuleName.ToLower()
            $modulePath = $module.FileName.ToLower()
            
            # Verd√§chtige Module-Namen
            $suspiciousNames = @(
                "inject", "hook", "cheat", "hack", "client", "loader",
                "bypass", "ghost", "stealth", "undetectable", "hidden",
                "meter", "wrst", "arst", "future", "liquid", "rusher",
                "phobos", "konas", "salhack", "gamesense", "pyro"
            )
            
            # Nicht-System DLL Pfade
            $nonSystemPaths = @(
                "appdata", "temp", "downloads", "desktop", "documents",
                "minecraft", "mods", "versions", ".cache", "roaming"
            )
            
            foreach ($susName in $suspiciousNames) {
                if ($moduleName -match $susName -or $modulePath -match $susName) {
                    $score += 25
                    $suspiciousModules += $module.FileName
                    Write-Host "    ‚ùå Verd√§chtiges Modul: $($module.ModuleName)" -ForegroundColor Red
                    break
                }
            }
            
            # Pr√ºfe ob DLL nicht aus System-Ordnern kommt
            $isSystemDll = $modulePath -match "\\windows\\" -or 
                          $modulePath -match "\\system32\\" -or 
                          $modulePath -match "\\java\\" -or
                          $modulePath -match "\\jre\\" -or
                          $modulePath -match "\\jdk\\"
            
            if (-not $isSystemDll) {
                foreach ($nonSysPath in $nonSystemPaths) {
                    if ($modulePath -match $nonSysPath) {
                        $score += 15
                        Write-Host "    ‚ö† Nicht-System DLL: $($module.ModuleName)" -ForegroundColor Yellow
                        Write-Host "      Pfad: $($module.FileName)" -ForegroundColor Gray
                        break
                    }
                }
            }
        }
        
        if ($suspiciousModules.Count -gt 0) {
            Write-Host "    üìå Verd√§chtige Module gefunden: $($suspiciousModules.Count)" -ForegroundColor Yellow
        }
        
    } catch {
        # Fehler ignorieren
    }
    
    return $score
}

function Scan-DLL-Injections($pid) {
    $score = 0
    
    try {
        # Verwende Process Explorer √§hnliche Techniken
        $proc = Get-Process -Id $pid -ErrorAction Stop
        
        # 1. Remote Thread Detection
        $threads = Get-WmiObject Win32_Thread -Filter "ProcessHandle=$($proc.Handle)" -ErrorAction SilentlyContinue
        if ($threads.Count -gt 50) {  # Ungew√∂hnlich viele Threads
            $score += 10
            Write-Host "    ‚ö† Viele Threads: $($threads.Count)" -ForegroundColor Yellow
        }
        
        # 2. Handle Count Check
        if ($proc.HandleCount -gt 1000) {  # Sehr viele Handles
            $score += 10
            Write-Host "    ‚ö† Viele Handles: $($proc.HandleCount)" -ForegroundColor Yellow
        }
        
        # 3. Loaded DLLs with suspicious timestamps
        $dlls = $proc.Modules | Where-Object { $_.ModuleName -like "*.dll" }
        foreach ($dll in $dlls) {
            try {
                $dllFile = Get-Item $dll.FileName -ErrorAction Stop
                $timeDiff = (Get-Date) - $dllFile.LastWriteTime
                
                # DLL wurde k√ºrzlich modifiziert (w√§hrend Minecraft l√§uft)
                if ($timeDiff.TotalMinutes -lt 10 -and $dllFile.LastWriteTime -gt $proc.StartTime) {
                    $score += 20
                    Write-Host "    ‚ùå K√ºrzlich geladene DLL: $($dll.ModuleName)" -ForegroundColor Red
                    Write-Host "      Modifiziert: $($dllFile.LastWriteTime)" -ForegroundColor Gray
                }
            } catch {
                continue
            }
        }
        
    } catch {
        # Fehler ignorieren
    }
    
    return $score
}

function Scan-Network-Connections($pid) {
    $score = 0
    
    try {
        # Netstat alternative f√ºr PowerShell
        $connections = netstat -ano | Select-String ":$pid\s"
        
        $suspiciousPorts = @(1337, 1338, 25565, 8080, 8888, 9999)
        $suspiciousIPs = @()
        
        foreach ($conn in $connections) {
            $line = $conn.ToString()
            
            # Pr√ºfe auf verd√§chtige Ports
            foreach ($port in $suspiciousPorts) {
                if ($line -match ":$port\s") {
                    $score += 15
                    Write-Host "    ‚ö† Verd√§chtiger Port: $port" -ForegroundColor Yellow
                    Write-Host "      Verbindung: $line" -ForegroundColor Gray
                }
            }
            
            # Pr√ºfe auf lokale Verbindungen (m√∂glicher Cheat-Server)
            if ($line -match "127\.0\.0\.1|localhost|0\.0\.0\.0") {
                $score += 10
                Write-Host "    ‚ö† Lokale Verbindung erkannt" -ForegroundColor Yellow
            }
        }
        
    } catch {
        # Fehler ignorieren
    }
    
    return $score
}

function Scan-Process-Hooks($pid) {
    $score = 0
    
    try {
        # Process Hacker API √§hnliche Checks
        $proc = Get-Process -Id $pid -ErrorAction Stop
        
        # 1. Check for debug privileges
        $token = Get-WmiObject Win32_Process -Filter "ProcessId=$pid" | 
                 Select-Object @{Name="Token";Expression={$_.GetOwnerSid()}}
        
        # 2. Check for unusual parent processes
        $parentPid = (Get-CimInstance Win32_Process -Filter "ProcessId=$pid").ParentProcessId
        $parentProc = Get-Process -Id $parentPid -ErrorAction SilentlyContinue
        
        if ($parentProc -and $parentProc.ProcessName -notmatch "explorer|javaw|java") {
            $score += 15
            Write-Host "    ‚ö† Ungew√∂hnlicher Parent: $($parentProc.ProcessName)" -ForegroundColor Yellow
        }
        
        # 3. Check for handle duplication (Injection Technik)
        $handles = Get-WmiObject Win32_Handle -Filter "ProcessId=$pid" -ErrorAction SilentlyContinue
        if ($handles -and $handles.Count -gt 200) {
            $score += 10
            Write-Host "    ‚ö† Viele Handles (m√∂gliche Injection)" -ForegroundColor Yellow
        }
        
    } catch {
        # Fehler ignorieren
    }
    
    return $score
}

# ---------------- DETAILED ANALYSIS FUNCTIONS ----------------

function Show-DLL-Details {
    Show-Banner
    Show-Section "üîç DLL INJECTION DETAILS"
    
    $allDLLs = @()
    
    $processes = Get-Process | Where-Object { $_.ProcessName -match "^(java|javaw)" }
    
    foreach ($proc in $processes) {
        Write-Host "`n  üéÆ Prozess: $($proc.ProcessName) (PID: $($proc.Id))" -ForegroundColor Cyan
        
        try {
            $modules = $proc.Modules | Where-Object { $_.ModuleName -like "*.dll" }
            
            foreach ($module in $modules) {
                $isSuspicious = $false
                $suspicionReasons = @()
                
                # Suspicion Checks
                $modulePath = $module.FileName.ToLower()
                
                if ($modulePath -match "temp|appdata|downloads|desktop") {
                    $isSuspicious = $true
                    $suspicionReasons += "Nicht-System Pfad"
                }
                
                if ($module.ModuleName -match "inject|hook|cheat|client") {
                    $isSuspicious = $true
                    $suspicionReasons += "Verd√§chtiger Name"
                }
                
                try {
                    $fileInfo = Get-Item $module.FileName -ErrorAction Stop
                    $signature = Get-AuthenticodeSignature $module.FileName -ErrorAction SilentlyContinue
                    
                    if ($signature.Status -ne "Valid") {
                        $isSuspicious = $true
                        $suspicionReasons += "Nicht signiert"
                    }
                } catch {
                    $isSuspicious = $true
                    $suspicionReasons += "Keine Signatur info"
                }
                
                $dllInfo = [PSCustomObject]@{
                    Process = $proc.ProcessName
                    PID = $proc.Id
                    DLLName = $module.ModuleName
                    Path = $module.FileName
                    IsSuspicious = $isSuspicious
                    Reasons = $suspicionReasons -join ", "
                    Size = "$([math]::Round($module.FileSize / 1KB, 2)) KB"
                }
                
                $allDLLs += $dllInfo
                
                if ($isSuspicious) {
                    Write-Host "    ‚ùå $($module.ModuleName)" -ForegroundColor Red
                    Write-Host "      Pfad: $($module.FileName)" -ForegroundColor Gray
                    Write-Host "      Grund: $($suspicionReasons -join ', ')" -ForegroundColor Yellow
                } else {
                    Write-Host "    ‚úì $($module.ModuleName)" -ForegroundColor Green
                }
            }
            
        } catch {
            Write-Host "    ‚ö† Zugriff verweigert" -ForegroundColor Yellow
        }
    }
    
    $suspiciousCount = ($allDLLs | Where-Object { $_.IsSuspicious }).Count
    
    Write-Host ""
    Show-Result "Total DLLs: $($allDLLs.Count)" "INFO"
    Show-Result "Verd√§chtige DLLs: $suspiciousCount" $(if ($suspiciousCount -gt 0) { "WARN" } else { "GOOD" })
    
    if ($suspiciousCount -gt 0) {
        Write-Host ""
        Show-Result "Verd√§chtige DLL Details:" "INFO"
        $allDLLs | Where-Object { $_.IsSuspicious } | ForEach-Object {
            Write-Host "    ‚Ä¢ $($_.DLLName) in $($_.Process) (PID: $($_.PID))" -ForegroundColor Yellow
            Write-Host "      Pfad: $($_.Path)" -ForegroundColor Gray
            Write-Host "      Grund: $($_.Reasons)" -ForegroundColor DarkGray
        }
    }
    
    Read-Host "`nDr√ºcke Enter um fortzufahren"
    Start-InjectableCheatScan
}

function Run-Memory-Scan {
    Show-Banner
    Show-Section "üß† MEMORY SCAN"
    
    Write-Host "  üîç Scanne Java-Prozess Speicher auf Cheat-Signaturen..." -ForegroundColor Cyan
    Write-Host ""
    
    $cheatPatterns = @{
        # Memory Signaturen bekannter Cheats
        "Meteor Client" = @("meteorclient", "minegame159", "meteor\\/client")
        "Wurst Client" = @("wurstclient", "net\\.wurst", "Wurst\\ Client")
        "Aristois" = @("aristois", "me\\.aristois", "Aristois\\ Client")
        "Future Client" = @("futureclient", "future\\/client")
        "LiquidBounce" = @("liquidbounce", "net\\.ccbluex")
        "AutoCrystal" = @("autocrystal", "crystalaura", "placecrystal")
        "KillAura" = @("killaura", "entityaura", "multiaura")
        "Reach" = @("reach", "attackrange", "hitrange")
        "Velocity" = @("velocity", "knockback", "antiknockback")
    }
    
    $processes = Get-Process | Where-Object { $_.ProcessName -match "^(java|javaw)" }
    
    $foundPatterns = @()
    
    foreach ($proc in $processes) {
        Write-Host "  üìä Prozess: $($proc.ProcessName) (PID: $($proc.Id))" -ForegroundColor White
        
        try {
            # Versuche Memory zu lesen (begrenzte Bereiche)
            $memoryInfo = Get-WmiObject Win32_Process -Filter "ProcessId=$($proc.Id)"
            $workingSet = [math]::Round($memoryInfo.WorkingSetSize / 1MB, 2)
            
            Write-Host "    üíæ Working Set: ${workingSet}MB" -ForegroundColor Gray
            
            # Check for suspicious memory regions
            if ($workingSet -gt 4000) {  # > 4GB f√ºr Minecraft ist verd√§chtig
                Write-Host "    ‚ö† Hoher Speicherverbrauch (m√∂gliche Injection)" -ForegroundColor Yellow
                $foundPatterns += "Hoher Speicherverbrauch in PID $($proc.Id)"
            }
            
            # Pr√ºfe auf verd√§chtige Handle-Typen
            $handles = Get-WmiObject Win32_Process -Filter "ProcessId=$($proc.Id)" | 
                      Select-Object HandleCount, ThreadCount
            
            if ($handles.HandleCount -gt 1500) {
                Write-Host "    ‚ö† Viele Handles: $($handles.HandleCount)" -ForegroundColor Yellow
                $foundPatterns += "Viele Handles in PID $($proc.Id)"
            }
            
        } catch {
            Write-Host "    ‚ö† Memory Zugriff verweigert" -ForegroundColor Yellow
        }
    }
    
    Write-Host ""
    
    if ($foundPatterns.Count -eq 0) {
        Show-Result "Keine verd√§chtigen Memory-Muster gefunden" "GOOD"
    } else {
        Show-Result "Verd√§chtige Memory-Muster gefunden!" "WARN"
        Write-Host ""
        foreach ($pattern in $foundPatterns) {
            Write-Host "    ‚Ä¢ $pattern" -ForegroundColor Yellow
        }
    }
    
    Read-Host "`nDr√ºcke Enter um fortzufahren"
    Start-InjectableCheatScan
}

function Show-Network-Details {
    Show-Banner
    Show-Section "üåê NETZWERKVERBINDUNGEN"
    
    Write-Host "  üîç Analysiere Netzwerkverbindungen von Java-Prozessen..." -ForegroundColor Cyan
    Write-Host ""
    
    # Verwende netstat f√ºr bessere Details
    $netstatOutput = netstat -ano | Select-String "ESTABLISHED|LISTENING"
    
    $javaConnections = @()
    $suspiciousConnections = @()
    
    foreach ($line in $netstatOutput) {
        if ($line -match ":(\d+)\s+(\S+):(\d+)\s+(\w+)\s+(\d+)") {
            $localPort = $matches[1]
            $remoteAddr = $matches[2]
            $remotePort = $matches[3]
            $state = $matches[4]
            $pid = $matches[5]
            
            $proc = Get-Process -Id $pid -ErrorAction SilentlyContinue
            
            if ($proc -and $proc.ProcessName -match "java|javaw") {
                $connInfo = [PSCustomObject]@{
                    PID = $pid
                    Process = $proc.ProcessName
                    LocalPort = $localPort
                    RemoteAddress = $remoteAddr
                    RemotePort = $remotePort
                    State = $state
                }
                
                $javaConnections += $connInfo
                
                # Verd√§chtige Verbindungen erkennen
                $isSuspicious = $false
                $suspicionReason = ""
                
                # Lokaler Cheat-Server
                if ($remoteAddr -match "127\.0\.0\.1|localhost") {
                    $isSuspicious = $true
                    $suspicionReason = "Lokale Verbindung"
                }
                
                # Bekannte Cheat-Ports
                $cheatPorts = @(1337, 1338, 25566, 8080, 8888, 9999, 25565)
                if ($cheatPorts -contains $remotePort) {
                    $isSuspicious = $true
                    $suspicionReason = "Verd√§chtiger Port: $remotePort"
                }
                
                # Viele Verbindungen vom gleichen Prozess
                $connCount = ($javaConnections | Where-Object { $_.PID -eq $pid }).Count
                if ($connCount -gt 10) {
                    $isSuspicious = $true
                    $suspicionReason = "Viele Verbindungen: $connCount"
                }
                
                if ($isSuspicious) {
                    $suspiciousConnections += $connInfo
                    Write-Host "    ‚ö† PID $pid -> $remoteAddr:$remotePort ($state)" -ForegroundColor Yellow
                    Write-Host "      Grund: $suspicionReason" -ForegroundColor Gray
                } else {
                    Write-Host "    ‚úì PID $pid -> $remoteAddr:$remotePort ($state)" -ForegroundColor Green
                }
            }
        }
    }
    
    Write-Host ""
    Show-Result "Total Java Verbindungen: $($javaConnections.Count)" "INFO"
    Show-Result "Verd√§chtige Verbindungen: $($suspiciousConnections.Count)" $(if ($suspiciousConnections.Count -gt 0) { "WARN" } else { "GOOD" })
    
    if ($suspiciousConnections.Count -gt 0) {
        Write-Host ""
        Show-Result "Verd√§chtige Verbindungen Details:" "INFO"
        $suspiciousConnections | Group-Object PID | ForEach-Object {
            $proc = Get-Process -Id $_.Name -ErrorAction SilentlyContinue
            Write-Host "    ‚Ä¢ PID $($_.Name) ($($proc.ProcessName)): $($_.Count) verd√§chtige Verbindungen" -ForegroundColor Yellow
        }
    }
    
    Read-Host "`nDr√ºcke Enter um fortzufahren"
    Start-InjectableCheatScan
}

function Find-Hidden-Processes {
    Show-Banner
    Show-Section "üïµÔ∏è‚Äç‚ôÇÔ∏è VERSTECKTE PROZESSE"
    
    Write-Host "  üîç Suche nach versteckten/unsichtbaren Prozessen..." -ForegroundColor Cyan
    Write-Host ""
    
    $allProcesses = Get-Process
    $hiddenProcesses = @()
    
    # 1. Prozesse ohne MainWindowHandle (unsichtbar)
    $noWindowProcesses = $allProcesses | Where-Object { 
        $_.MainWindowHandle -eq 0 -and 
        $_.ProcessName -notmatch "^(svchost|dllhost|conhost|background)" -and
        $_.ProcessName -match "java|inject|hook|cheat|client"
    }
    
    foreach ($proc in $noWindowProcesses) {
        Write-Host "    ‚ö† Versteckter Prozess: $($proc.ProcessName) (PID: $($proc.Id))" -ForegroundColor Yellow
        Write-Host "      Speicher: $([math]::Round($proc.WorkingSet64 / 1MB, 2))MB" -ForegroundColor Gray
        
        $hiddenProcesses += [PSCustomObject]@{
            Name = $proc.ProcessName
            PID = $proc.Id
            Type = "Kein Fenster"
            Memory = "$([math]::Round($proc.WorkingSet64 / 1MB, 2))MB"
        }
    }
    
    # 2. Prozesse mit verd√§chtigen Parent-Processes
    $allPids = $allProcesses | Select-Object -ExpandProperty Id
    
    foreach ($pid in $allPids) {
        try {
            $proc = Get-CimInstance Win32_Process -Filter "ProcessId=$pid"
            $parentPid = $proc.ParentProcessId
            
            if ($parentPid -ne 0) {
                $parentProc = Get-Process -Id $parentPid -ErrorAction SilentlyContinue
                
                # Verd√§chtige Parent-Kombinationen
                if ($parentProc -and $proc.Name -match "java" -and $parentProc.ProcessName -match "cmd|powershell|rundll32") {
                    Write-Host "    ‚ö† Verd√§chtiger Parent: $($proc.Name) (Kind von $($parentProc.ProcessName))" -ForegroundColor Yellow
                    
                    $hiddenProcesses += [PSCustomObject]@{
                        Name = $proc.Name
                        PID = $pid
                        Type = "Verd√§chtiger Parent"
                        Memory = "N/A"
                    }
                }
            }
        } catch {
            continue
        }
    }
    
    Write-Host ""
    
    if ($hiddenProcesses.Count -eq 0) {
        Show-Result "Keine versteckten Prozesse gefunden" "GOOD"
    } else {
        Show-Result "Versteckte Prozesse gefunden: $($hiddenProcesses.Count)" "WARN"
        Write-Host ""
        $hiddenProcesses | ForEach-Object {
            Write-Host "    ‚Ä¢ $($_.Name) (PID: $($_.PID)) - $($_.Type)" -ForegroundColor Yellow
        }
    }
    
    Read-Host "`nDr√ºcke Enter um fortzufahren"
    Start-InjectableCheatScan
}

function Analyze-Event-Logs {
    Show-Banner
    Show-Section "üìù EVENT LOG ANALYSE"
    
    Write-Host "  üîç Analysiere Windows Ereignisprotokolle auf Injection-Aktivit√§ten..." -ForegroundColor Cyan
    Write-Host ""
    
    $injectionEvents = @()
    $startTime = (Get-Date).AddHours(-1)  # Letzte Stunde
    
    # 1. Process Creation Events
    try {
        $processEvents = Get-WinEvent -FilterHashtable @{
            LogName = 'Security'
            ID = 4688  # New Process
            StartTime = $startTime
        } -MaxEvents 50 -ErrorAction SilentlyContinue | Where-Object {
            $_.Properties[5].Value -match "java|javaw|inject|dll"
        }
        
        foreach ($event in $processEvents) {
            $procName = $event.Properties[5].Value
            $user = $event.Properties[1].Value
            $time = $event.TimeCreated
            
            Write-Host "    ‚è∞ $time" -ForegroundColor Gray
            Write-Host "      üë§ $user startete: $procName" -ForegroundColor White
            
            $injectionEvents += [PSCustomObject]@{
                Time = $time
                User = $user
                Event = "Process Created: $procName"
                Type = "Process Creation"
            }
        }
    } catch {
        Write-Host "    ‚ö† Event Log Zugriff fehlgeschlagen" -ForegroundColor Yellow
    }
    
    # 2. DLL Load Events
    try {
        $dllEvents = Get-WinEvent -FilterHashtable @{
            LogName = 'Microsoft-Windows-Diagnostics-Performance/Operational'
            ID = 100  # DLL Load
            StartTime = $startTime
        } -MaxEvents 30 -ErrorAction SilentlyContinue
        
        foreach ($event in $dllEvents) {
            if ($event.Message -match "java|inject|cheat") {
                Write-Host "    üì¶ DLL Load Event: $($event.TimeCreated)" -ForegroundColor Gray
                Write-Host "      $($event.Message.Split("`n")[0])" -ForegroundColor White
                
                $injectionEvents += [PSCustomObject]@{
                    Time = $event.TimeCreated
                    User = "System"
                    Event = "DLL Loaded"
                    Type = "DLL Activity"
                }
            }
        }
    } catch {
        # Event Log m√∂glicherweise nicht verf√ºgbar
    }
    
    Write-Host ""
    
    if ($injectionEvents.Count -eq 0) {
        Show-Result "Keine verd√§chtigen Event Log Eintr√§ge gefunden" "GOOD"
    } else {
        Show-Result "Verd√§chtige Event Log Eintr√§ge: $($injectionEvents.Count)" "WARN"
        Write-Host ""
       
